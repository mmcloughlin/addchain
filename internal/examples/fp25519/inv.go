// Code generated by addchain. DO NOT EDIT.

package fp25519

// Inv computes z = 1/x (mod p) and returns it.
func (z *Elt) Inv(x *Elt) *Elt {
	// Inversion computation is derived from the addition chain:
	//
	//	_10       = 2*1
	//	_11       = 1 + _10
	//	_1100     = _11 << 2
	//	_1111     = _11 + _1100
	//	_11110000 = _1111 << 4
	//	_11111111 = _1111 + _11110000
	//	x10       = _11111111 << 2 + _11
	//	x20       = x10 << 10 + x10
	//	x30       = x20 << 10 + x10
	//	x60       = x30 << 30 + x30
	//	x120      = x60 << 60 + x60
	//	x240      = x120 << 120 + x120
	//	x250      = x240 << 10 + x10
	//	return      (x250 << 2 + 1) << 3 + _11
	//
	// Operations: 254 squares 12 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Allocate Temporaries.
	var (
		t0 = new(Elt)
		t1 = new(Elt)
		t2 = new(Elt)
		t3 = new(Elt)
		t4 = new(Elt)
	)

	// Step 1: t0 = x^0x2
	t0.Sqr(x)

	// Step 2: t0 = x^0x3
	t0.Mul(x, t0)

	// Step 4: t1 = x^0xc
	t1.Sqr(t0)
	for s := 1; s < 2; s++ {
		t1.Sqr(t1)
	}

	// Step 5: t1 = x^0xf
	t1.Mul(t0, t1)

	// Step 9: t2 = x^0xf0
	t2.Sqr(t1)
	for s := 1; s < 4; s++ {
		t2.Sqr(t2)
	}

	// Step 10: t1 = x^0xff
	t1.Mul(t1, t2)

	// Step 12: t1 = x^0x3fc
	for s := 0; s < 2; s++ {
		t1.Sqr(t1)
	}

	// Step 13: t1 = x^0x3ff
	t1.Mul(t0, t1)

	// Step 23: t2 = x^0xffc00
	t2.Sqr(t1)
	for s := 1; s < 10; s++ {
		t2.Sqr(t2)
	}

	// Step 24: t2 = x^0xfffff
	t2.Mul(t1, t2)

	// Step 34: t2 = x^0x3ffffc00
	for s := 0; s < 10; s++ {
		t2.Sqr(t2)
	}

	// Step 35: t2 = x^0x3fffffff
	t2.Mul(t1, t2)

	// Step 65: t3 = x^0xfffffffc0000000
	t3.Sqr(t2)
	for s := 1; s < 30; s++ {
		t3.Sqr(t3)
	}

	// Step 66: t2 = x^0xfffffffffffffff
	t2.Mul(t2, t3)

	// Step 126: t3 = x^0xfffffffffffffff000000000000000
	t3.Sqr(t2)
	for s := 1; s < 60; s++ {
		t3.Sqr(t3)
	}

	// Step 127: t2 = x^0xffffffffffffffffffffffffffffff
	t2.Mul(t2, t3)

	// Step 247: t3 = x^0xffffffffffffffffffffffffffffff000000000000000000000000000000
	t3.Sqr(t2)
	for s := 1; s < 120; s++ {
		t3.Sqr(t3)
	}

	// Step 248: t2 = x^0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t2.Mul(t2, t3)

	// Step 258: t2 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00
	for s := 0; s < 10; s++ {
		t2.Sqr(t2)
	}

	// Step 259: t1 = x^0x3ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t1.Mul(t1, t2)

	// Step 261: t1 = x^0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc
	for s := 0; s < 2; s++ {
		t1.Sqr(t1)
	}

	// Step 262: t4 = x^0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd
	t4.Mul(x, t1)

	// Step 265: t4 = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe8
	for s := 0; s < 3; s++ {
		t4.Sqr(t4)
	}

	// Step 266: z = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeb
	z.Mul(t0, t4)

	return z
}
