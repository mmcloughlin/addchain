<p align="center">
  <img src="logo.svg" width="40%" border="0" alt="addchain" />
</p>

<p align="center">Cryptographic Addition Chain Generation in Go</p>

`addchain` generates short addition chains for exponents of cryptographic
interest with [results](#results) rivaling the best hand-optimized chains.
Intended as a building block in elliptic curve or other cryptographic code
generators.

* Suite of algorithms from academic research: continued fractions,
  dictionary-based and Bos-Coster heuristics
* Custom run-length techniques exploit structure of cryptographic exponents
  with excellent results on Solinas primes
* Generic optimization methods eliminate redundant operations
* Simple domain-specific language for addition chain computations
* Command-line interface or library

## Results

Results for common cryptographic exponents and delta compared to [best known
hand-optimized addition
chains](https://briansmith.org/ecc-inversion-addition-chains-01).

| Name | Length | Best | Delta |
| ---- | -----: | ---: | ----: |
{{ range .Results -}}
{{- if gt .BestKnown 0 -}}
| [{{ .Name }}](doc/results.md#{{ anchor .Name }}) | {{ .Length }} | {{ .BestKnown }} | {{ printf "%+d" .Delta }} |
{{ end -}}
{{ end }}

See [full results listing](doc/results.md) for more detail and additional
exponents.

## Usage

### Command-line Interface

Install:

```
go get -u github.com/mmcloughlin/addchain/cmd/addchain
```

Search for a curve25519 field inversion addition chain with:

```sh
{{ include "internal/examples/cli/cmd.sh" -}}
```

Output:

```
{{ include "internal/examples/cli/output" -}}
```

### Library

Install:

```
go get -u github.com/mmcloughlin/addchain
```

Algorithms all conform to the {{ sym "alg" "ChainAlgorithm" }} or
{{ sym "alg" "SequenceAlgorithm" }} interfaces and can be used directly. However the
most user-friendly method uses the {{ pkg "alg/ensemble" }} package to
instantiate a sensible default set of algorithms and the {{ pkg "alg/exec" }}
helper to execute them in parallel. The following code uses this method to
find an addition chain for curve25519 field inversion:

```go
{{ snippet "alg/exec/example_test.go" "func Example" "^}" -}}
```

## Algorithms

### Binary

The {{ pkg "alg/binary" }} package implements the addition chain equivalent
of the basic [square-and-multiply exponentiation
method](https://en.wikipedia.org/wiki/Exponentiation_by_squaring). It is
included for completeness, but is almost always outperformed by more advanced
algorithms below.

### Continued Fractions

The {{ pkg "alg/contfrac" }} package implements the continued fractions
methods for addition sequence search introduced by
Bergeron-Berstel-Brlek-Duboc in 1989 and later extended. This approach
utilizes a decomposition of an addition chain akin to continued fractions,
namely

```
(1,..., k,..., n) = (1,...,n mod k,..., k) {{ "\u2297" }} (1,..., n/k) {{ "\u2295" }} (n mod k).
```

for certain special operators {{ "\u2297" }} and {{ "\u2295" }}. This
decomposition lends itself to a recursive algorithm for efficient addition
sequence search, with results dependent on the _strategy_ for choosing the
auxillary integer _k_. The {{ pkg "alg/contfrac" }} package provides a
laundry list of strategies from the literature: binary, co-binary,
dichotomic, dyadic, fermat, square-root and total.

#### References

* {{ bibentry "contfrac" }}
* {{ bibentry "efficientcompaddchain" }}
* {{ bibentry "gencontfrac" }}
* {{ bibentry "hehcc:exp" }}

### Bos-Coster Heuristics

Bos and Coster described an iterative algorithm for efficient addition
sequence generation in which at each step a heuristic proposes new numbers
for the sequence in such a way that the _maximum_ number always decreases.
The [original Bos-Coster paper]({{ biburl "boscoster" }}) defined four
heuristics: Approximation, Divison, Halving and Lucas. Package
{{ pkg "alg/heuristic" }} implements a variation on these heuristics:

* **Approximation:** looks for two elements a, b in the current sequence with sum close to the largest element.
* **Halving:** applies when the target is at least twice as big as the next largest, and if so it will propose adding a sequence of doublings.
* **Delta Largest:** proposes adding the delta between the largest two entries in the current sequence.

Divison and Lucas are not implemented due to disparities in the literature
about their precise definition and poor results from early experiments.
Furthermore, this library does not apply weights to the heuristics as
suggested in the paper, rather it simply uses the first that applies. However
both of these remain [possible avenues for
improvement](https://github.com/mmcloughlin/addchain/issues/26).

#### References

* {{ bibentry "boscoster" }}
* {{ bibentry "github:kwantam/addchain" }}
* {{ bibentry "hehcc:exp" }}
* {{ bibentry "modboscoster" }}
* {{ bibentry "mpnt" }}
* {{ bibentry "speedsubgroup" }}

### Dictionary

Dictionary methods decompose the binary representation of a target integer _n_ into a set of dictionary _terms_, such that _n_
may be written as a sum

```
n = {{ "\u2211" }} 2^{e_i} d_i
```

for exponents _e_ and elements _d_ from a dictionary _D_. Given such a decomposition we can construct an addition chain for _n_ by

1. Find a short addition _sequence_ containing every element of the dictionary _D_. Continued fractions and Bos-Coster heuristics can be used here.
2. Build _n_ from the dictionary terms according to the sum decomposition.

The efficiency of this approach boils down to the decomposition method. The {{ pkg "alg/dict" }} package provides:

* **Fixed Window:** binary representation of _n_ is broken into fixed _k_-bit windows
* **Sliding Window**: break _n_ into _k_-bit windows, skipping zeros where possible
* **Run Length**: decompose _n_ into runs of 1s up to a maximal length
* **Hybrid**: mix of sliding window and run length methods

#### References

* {{ bibentry "braueraddsubchains" }}
* {{ bibentry "genshortchains" }}
* {{ bibentry "hehcc:exp" }}

### Runs

### Optimization

## Thanks

Thank you to [Tom Dean](https://web.stanford.edu/~trdean/), [Riad
Wahby](https://wahby.org/) and [Brian Smith](https://briansmith.org/) for
advice and encouragement.

## Contributing

Contributions to `addchain` are welcome:

* [Submit bug reports](https://github.com/mmcloughlin/addchain/issues/new) to
  the issues page.
* Suggest [test cases](https://github.com/mmcloughlin/addchain/blob/e6c070065205efcaa02627ab1b23e8ce6aeea1db/internal/results/results.go#L62)
  or update best-known hand-optimized results.
* Pull requests accepted. Please discuss in the [issues section](https://github.com/mmcloughlin/addchain/issues)
  before starting significant work.

## License

`addchain` is available under the [BSD 3-Clause License](LICENSE).
